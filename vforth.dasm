:START
        SET I, test             ; initialize next word ptr
        SET J, [R0_VAR]         ; initialize return stack
        SET SP, [S0_VAR]        ; initialize parameter stack

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; test is a test of the forth threaded-code model.
;;; It simply contains address of 'primitive' words.
;;; A primitive word has some instructions then a NEXT macro.
:test
        DAT WORD_
        DAT show_stack_in_x_y_z
        DAT CRASH

;;; For debugging display top 3 items on parameter stack in registers X Y Z.
;;; Z is top of stack.
:show_stack_in_x_y_z
        SET A, SP
        SET X, [A+2]
        SET Y, [A+1]
        SET Z, [A]
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; used interpret compiled words
:DOCOL
        SUB J, 1                ; push I onto return stack
        SET [J], I
        ADD A, 1                ; A points to codeword, so make
        SET I, A                ; I point to first data word
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;;
;;; Primitive words
;;;

;;; DROP ( x -- ) remove x from the stack
:_DROP
        DAT 0, 4, "DROP"        ; first word, size of string, string name of word
:DROP
        SET A, POP              ; drop top of stack

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; SWAP ( x1 x2 -- x2 x1 ) exchange the top two stack items
:_SWAP
        DAT _DROP, 4, "SWAP"
:SWAP
        SET A, POP              ; swap top to items on stack
        SET B, POP
        SET PUSH, A
        SET PUSH, B

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; DUP ( x -- x x ) duplicate top of stack
:_DUP
        DAT _SWAP, 3, "DUP"
:DUP
        SET A, SP               ; duplicate top of stack
        SET B, [A]
        SET PUSH, B
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; OVER ( x1 x2 -- x1 x2 x1 )
:_OVER
        DAT _DUP, 4, "OVER"
:OVER
        SET A, SP               ; get second element of stack
        SET PUSH, [A+1]         ; and push it on top

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; ROT ( a b c -- c a b )
:_ROT
        DAT _OVER, 3, "ROT"
:ROT
        SET A, POP
        SET B, POP
        SET C, POP
        SET PUSH, B
        SET PUSH, A
        SET PUSH, C

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; -ROT ( a b c -- b c a )
:_MINROT
        DAT _ROT, 4, "-ROT"
:MINROT
        SET A, POP
        SET B, POP
        SET C, POP
        SET PUSH, A
        SET PUSH, C
        SET PUSH, B

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 2DROP ( a b -- )
:_TWODROP
        DAT _MINROT, 5, "2DROP"
:TWODROP
        SET A, POP
        SET B, POP

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 2SWAP ( a b c d -- c d a b )
:_TWOSWAP
        DAT _TWODROP, 5, "2SWAP"
:TWOSWAP
        SET A, POP
        SET B, POP
        SET C, POP
        SET X, POP
        SET PUSH, B
        SET PUSH, A
        SET PUSH, X
        SET PUSH, C

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; ?DUP ( a -- a a ) if a is non-zero, otherwise ( a -- a )
:_QDUP
        DAT _TWOSWAP, 4, "?DUP"
:QDUP
        SET A, SP
        IFN 0, [A]
        SET PUSH, [A]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 1+ ( a -- a+1 )
:_INCR
        DAT _QDUP, 2, "1+"
:INCR
        SET A, SP
        ADD [A], 1

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 1- ( a -- a-1 )
:_DECR
        DAT _INCR, 2, "1-"
:DECR
        SET A, SP
        SUB [A], 1

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; + ( a b -- a+b )
:_ADD
        DAT _DECR, 1, "+"
:ADD_
        SET A, POP
        ADD A, POP
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; - ( a b -- a-b )
:_SUB
        DAT _ADD, 1, "-"
:SUB_
        SET A, POP
        SUB A, POP
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; * ( a b -- a*b )
:_MUL
        DAT _SUB, 1, "*"
:MUL_
        SET A, POP
        MUL A, POP
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; / ( a b -- a/b )
:_DIV
        DAT _MUL, 1, "/"
:DIV_
        SET A, POP
        DIV A, POP
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; MOD ( a b -- a%b )
:_MOD
        DAT _DIV, 3, "MOD"
:MOD_
        SET A, POP
        MOD A, POP
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; /MOD ( a b -- a%b )
:_DIVMOD
        DAT _MOD, 4, "/MOD"
:DIVMOD
        SET A, POP
        SET B, POP
        SET X, A
        DIV A, B
        MOD X, B
        SET PUSH, X             ; push quotent
        SET PUSH, A             ; push mod

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; = ( a b - n )
:_EQUAL
        DAT _DIVMOD, 1, "="
:EQUAL
        SET A, POP
        SET B, POP
        IFE A, B
        SET PC, EQUAL_TRUE
        SET PUSH, 0
        SET PC, EQUAL_ENDIF
:EQUAL_TRUE
        SET PUSH, 0xffff
:EQUAL_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; <> ( a b - n )
:_NOTEQUAL
        DAT _EQUAL, 2, "<>"
:NOTEQUAL
        SET A, POP
        SET B, POP
        IFN A, B
        SET PC, NOTEQUAL_TRUE
        SET PUSH, 0
        SET PC, NOTEQUAL_ENDIF
:NOTEQUAL_TRUE
        SET PUSH, 0xffff
:NOTEQUAL_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; < ( a b - n )
:_LT
        DAT _NOTEQUAL, 1, "<"
:LT
        SET A, POP
        SET B, POP
        IFG A, B
        SET PC, LT_GT
        SET PUSH, 0
        SET PC, LT_ENDIF
:LT_GT
        IFE A, B
        SET PUSH, 0
        IFN A, B
        SET PUSH, 0xffff
:LT_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; > ( a b - n )
:_GT
        DAT _LT, 1, ">"
:GT
        SET A, POP
        SET B, POP
        IFG A, B
        SET PC, GT_FALSE
        SET PUSH, 0xffff
        SET PC, GT_ENDIF
:GT_FALSE
        SET PUSH, 0
:GT_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; <= ( a b - n )
:_LTE
        DAT _GT, 2, "<="
:LTE
        SET A, POP
        SET B, POP
        IFG A, B
        SET PC, LTE_TRUE
        SET PUSH, 0
        SET PC, LTE_ENDIF
:LTE_TRUE
        SET PUSH, 0xffff
:LTE_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; >= ( a b - n )
:_GTE
        DAT _LTE, 2, ">="
:GTE
        SET A, POP
        SET B, POP
        IFG A, B
        SET PC, GTE_GT
        SET PUSH, 0xffff
        SET PC, GTE_ENDIF
:GTE_GT
        IFE A, B
        SET PUSH, 0xffff
        IFN A, B
        SET PUSH, 0
:GTE_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 0= ( a -- n )   does top of stack equal zero
:_ISZERO
        DAT _GTE, 2, "0="
:ISZERO
        SET A, POP
        IFE A, 0
        SET PUSH, 0xffff
        IFN A, 0
        SET PUSH, 0

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A


;;; 0<> ( a -- n )   does top of stack not equal zero
:_ISNOTZERO
        DAT _ISZERO, 3, "0<>"
:ISNOTZERO
        SET A, POP
        IFE A, 0
        SET PUSH, 0
        IFN A, 0
        SET PUSH, 0xffff

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 0< ( a -- n )
:_LTZERO
        DAT _ISNOTZERO, 2, "0<"
:LTZERO
        SET A, POP
        IFG A, 0
        SET PC, LTZERO_FALSE
        IFE A, 0
        SET PC, LTZERO_FALSE
        SET PUSH, 0xffff
        SET PC, LTZERO_ENDIF
:LTZERO_FALSE
        SET PUSH, 0
:LTZERO_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 0> ( a -- n )
:_GTZERO
        DAT _LTZERO, 2, "0>"
:GTZERO
        SET A, POP
        IFG A, 0
        SET PC, GTZERO_TRUE
        SET PUSH, 0
        SET PC, GTZERO_ENDIF
:GTZERO_TRUE
        SET PUSH, 0xffff
:GTZERO_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 0<= ( a -- n )
:_LTEZERO
        DAT _LTZERO, 3, "0<="
:LTEZERO
        SET A, POP
        IFG A, 0
        SET PC, LTEZERO_FALSE
        SET PUSH, 0xffff
        SET PC, LTEZERO_ENDIF
:LTEZERO_FALSE
        SET PUSH, 0
:LTEZERO_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; 0>= ( a -- n )
:_GTEZERO
        DAT _LTEZERO, 3, "0>="
:GTEZERO
        SET A, POP
        IFG A, 0
        SET PC, GTEZERO_TRUE
        IFE A, 0
        SET PC, GTEZERO_TRUE
        SET PUSH, 0
        SET PC, GTEZERO_ENDIF
:GTEZERO_TRUE
        SET PUSH, 0xffff
:GTEZERO_ENDIF
        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; AND ( a b -- n )
:_AND
        DAT _GTEZERO, 3, "AND"
:AND_
        SET A, POP
        AND A, POP
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; OR ( a b -- n )
:_OR
        DAT _AND, 2, "OR"
:OR_
        SET A, POP
        BOR A, POP
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; XOR ( a b -- n )
:_XOR
        DAT _OR, 3, "XOR"
:XOR_
        SET A, POP
        XOR A, POP
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; INVERT ( a -- n )
:_INVERT
        DAT _XOR, 6, "INVERT"
:INVERT
        SET A, POP
        XOR A, 0xffff
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; EXIT ( -- )  Used to exit compiled words
:_EXIT
        DAT _INVERT, 4, "EXIT"
:EXIT
        SET I, [J]              ; pop return stack into I
        ADD J, 1

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; LIT ( -- )
:_LIT
        DAT _EXIT, 3, "LIT"
:LIT
        SET PUSH, [I]           ; push next 16-bit word onto parameter stack
        ADD I, 1                ; skip it

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; ! ( data addr -- ) store data at given addr
:_STORE
        DAT _LIT, 1, "!"
:STORE
        SET A, POP
        SET [A], POP

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; @ ( addr -- data ) fetch data at given addr
:_FETCH
        DAT _STORE, 1, "@"
:FETCH
        SET A, POP
        SET PUSH, [A]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; +! ( amount addr -- ) add amount to data at given addr
:_ADDSTORE
        DAT _FETCH, 2, "+!"
:ADDSTORE
        SET A, POP
        ADD [A], POP

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; -! ( amount addr -- ) subtract amount to data at given addr
:_SUBSTORE
        DAT _ADDSTORE, 2, "+!"
:SUBSTORE
        SET A, POP
        SUB [A], POP

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; >R ( x -- ) push x onto return stack
:_RSPPUSH
        DAT _SUBSTORE, 2, ">R"
:RSPPUSH
        SET A, POP              ; pop from param stack
        SUB J, 1                ; push onto return stack
        SET [J], A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; <R ( -- x ) pop top of return stack
:_RSPPOP
        DAT _RSPPUSH, 2, "<R"
:RSPPOP
        SET A, [J]              ; pop off of return stack
        ADD J, 1
        SET PUSH, A             ; push onto param stack

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; RSP@ ( -- x ) fetch top of return stack
:_RSPFETCH
        DAT _RSPPOP, 4, "RSP@"
:RSPFETCH
        SET PUSH, J

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; RSP! ( x -- ) store top of return stack
:_RSPSTORE
        DAT _RSPFETCH, 4, "RSP!"
:RSPSTORE
        SET J, POP

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; RDROP ( -- ) drop top of return stack
:_RDROP
        DAT _RSPSTORE, 5, "RDROP"
:RDROP
        ADD J, 1

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; DSP@ ( -- x ) fetch top of parameter stack
:_DSPFETCH
        DAT _RDROP, 4, "DSP@"
:DSPFETCH
        SET PUSH, SP

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; DSP! ( x -- ) store top of parameter stack
:_DSPSTORE
        DAT _DSPFETCH, 4, "DSP!"
:DSPSTORE
        SET A, POP
        SET SP, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;;
;;; variables/constants
;;;

:STATE_VAR
        DAT 0                   ; 0xffff if in compile mode
:DP_VAR
        DAT END                 ; free memory ptr
:LATEST_VAR
        DAT END                 ; dictionary ptr
:BASE_VAR
        DAT 10                  ; current radix for printing reading
:S0_VAR
        DAT 0xffff              ; top of parameter stack
:R0_VAR
        DAT 0x1000              ; top of return stack
:VERSION_VAR
        DAT 1                   ; current vforth version!
:F_IMMED_VAR
        DAT 0x8000
:F_HIDDEN_VAR
        DAT 0x4000
:F_LENMASK_VAR
        DAT 0x3fff

;;;
;;; variable access words
;;;

;;; STATE ( -- flag ) true if currently in compliation state
:_STATE
        DAT _DSPSTORE, 5, "STATE"
:STATE
        SET PUSH, [STATE_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; DP ( -- addr ) points to next free word of memory, compiled words go here.
:_DP
        DAT _STATE, 2, "DP"
:DP
        SET PUSH, [DP_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; LATEST ( -- addr ) dictionary ptr
:_LATEST
        DAT _DP, 6, "LATEST"
:LATEST
        SET PUSH, [LATEST_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; BASE ( -- radix ) current base for reading/printing
:_BASE
        DAT _LATEST, 4, "BASE"
:BASE
        SET PUSH, [BASE_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; S0 ( -- addr ) top of parameter stack
:_S0
        DAT _BASE, 2, "S0"
:S0
        SET PUSH, [S0_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; R0 ( -- addr ) top of parameter stack
:_R0
        DAT _S0, 2, "R0"
:R0_
        SET PUSH, [R0_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; VERSION ( -- version )
:_VERSION
        DAT _R0, 2, "VERSION"
:VERSION
        SET PUSH, [VERSION_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; F_IMMED ( -- mask )
:_F_IMMED
        DAT _VERSION, 7, "F_IMMED"
:F_IMMED
        SET PUSH, [F_IMMED_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; F_HIDDEN ( -- mask )
:_F_HIDDEN
        DAT _F_IMMED, 8, "F_HIDDEN"
:F_HIDDEN
        SET PUSH, [F_HIDDEN_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; F_LENMASK
:_F_LENMASK
        DAT _F_HIDDEN, 9, "F_LENMASK"
:F_LENMASK
        SET PUSH, [F_LENMASK_VAR]

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; KEY ( -- key ) currently reads from INPUT_STRING
:_KEY
        DAT _F_LENMASK, 3, "KEY"
:KEY
        JSR KEY_FUNC
        SET PUSH, A

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; RETURNS next key in A
:KEY_FUNC
        SET A, [CUR_KEY]
        IFN [A], 0
        SET PC, KEY_VALID
        SET PC, CRASH           ; crash on end of input
:KEY_VALID
        ADD [CUR_KEY], 1
        SET A, [A]
        SET PC, POP

;;; KEY variables
:CUR_KEY
        DAT INPUT_STRING
:INPUT_STRING
        DAT "ABC DEF", 0

;;; EMIT ( key -- ) currently just dumps into SCREEN
:_EMIT
        DAT _KEY, 4, "EMIT"
:EMIT
        SET A, POP
        BOR A, 0xF000           ; make it white
        SET B, [CURSOR]
        SET [B], A
        ADD [CURSOR], 1

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

;;; EMIT variables
:CURSOR
        DAT 0x8000
:SCREEN
        DAT 0x8000

;;; WORD ( -- ptr len ) returns length and ptr to word string
:_WORD
        DAT _EMIT, 4, "WORD"
:WORD_
        JSR KEY_FUNC
        IFE A, 0x005c          ; if backslash, skip the comment
        SET PC, WORD_3
        IFE A, 0x0020          ; if space, keep looking
        SET PC, WORD_

        ;; search for end of word storing characters as we go
        SET X, WORD_BUFFER      ; x is ptr into word_buffer
:WORD_2
        SET [X], A
        ADD X, 1
        JSR KEY_FUNC
        IFN A, 0x0020           ; if not space keep looping
        SET PC, WORD_2

        SUB X, WORD_BUFFER      ; calc length
        SET PUSH, X             ; push length
        SET PUSH, WORD_BUFFER   ; push str addr

        SET A, [I]              ; next
        ADD I, 1
        SET PC, A

        ;; skip until new-line
:WORD_3
        JSR KEY_FUNC
        IFN A, 0x000a           ; new line
        SET PC, WORD_3
        SET PC, WORD_

:WORD_BUFFER
        DAT "0123456789abcdef0123456789abcdef"  ; 32-char word buffer

:CRASH
        DAT 0xeee0             ; crash with illegal opcode

:END
